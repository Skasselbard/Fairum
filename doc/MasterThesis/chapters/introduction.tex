% !TEX root = ../main.tex
\chapter{Introduction}
\label{introduction}
\section{Motivation}
High quality work is the desire of a professional;
Consequently, high quality software is the desire of a professional software engineer.
However, achieving high quality software is an ambiguous task, since it is rather context dependent.
But some methods like static analysis or model checking can be automated to find common problems with little human effort.

Static analysis is typically part of programming languages.
One popular property this approach guarantees, is type safety.
But some recent programming languages like Rust\cite{Matsakis:2014:RL:2692956.2663188} make use of additional invariants.
In the case of Rust, the ownership model is the most notable additional concept of static analisis.
With strict mutability and aliasing rules, the ownership model avoids a variety of memory safety issues.
The price is restricted expressiveness, that manifests in compiler warnings previously unknown to other languages.

% TODO:
Model checking on th other hand is typically not a feature of programming languages, as it requires a mapping to a formalism.
But if such a mapping exists, desireable properties can be proven mathematically for all possible runs of a program.
One formalism that is especially suited to analyse flow of execution are Petri-nets.

In this work we will try to find a mapping between Rust programs and Petri-nets for the perpose of model checking.
We will check for a deadlock as an example property in a small program to prove the concept.

\section{Outline}
The structure of this work is as follows.

First we need to establish the basics.
In the background section we will first take a closer look on \hyperlink{rel_rust}{Rust}.
After that we will review the basic concept of compilers to learn how source code is translated into another representation.
Next we have to inspect the topic of \hyperlink{rel_mc}{Model Checking} with Petri-Nets and CTL*.
And finally we look into the efforts that have been done by others.

After we understand those principles, we can move on to the approach taken.
We will again start with the specifics of \hyperlink{app_rust}{Rust}.
How can we translate a Rust program into something we need,
and what language concepts do we need to understand.
We will see that the Rust language has an \hyperlink{app_mir}{intermediate representation} that simplifies our situation.
The most important part will be the \hyperlink{app_trans}{translation} of the language features to a petri net.
It will contain a detailed description of our mapping and its limits.
Next, the generated Petri-Net has to be analysed by a Model Checker. 
\hyperlink{app_mc}{How this is done} and our \hyperlink{app_test}{test scenario} we will discuss be discussed at the end of the chapter.

Finally wie will \hyperlink{results}{discuss the results} and infer \hyperlink{future}{future work} from the implementations shortcomings.

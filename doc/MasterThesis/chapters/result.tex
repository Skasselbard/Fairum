\chapter{Result}
\label{results}
\begin{verbatim}
- expected deadlocks (expected program termination)
- fitting formulas
  - exkurs in temporal logic
- structure of results
- examples
  - minimal deadlock
  - fixed minimal deadlock
  - deadlock with multiple threads
    - dining philosophers?
  - data dependent deadlock
  - maybe a real world example
    - some distributed system?
      - mqtt?
      - multiagent system?
\end{verbatim}


\section{Analysis}
\begin{verbatim}
  without the use of some data even most flow releated properties are not discoverable
  this makes emulation necessary
  a new local <-> memory model makes sense
  makes emulation easier but does not resolve the problem
  high lvl nets might resolve this issue at an unknown performance cost
  \end{verbatim}
  
  \section{Translation}
  \begin{verbatim}
  - how easy/mapping quality
      - flow is easy
      - data is difficult
          - data is moved between many locals
          - moving quickly masks semantic e.g. for mutexes
  - rusts borrow checking rules can probably be exploited better
  - foreign functions cannot be translated and must be emulated
      - special emulation makes sense for some of them
      - especially for flow relevant functions like threads and mutexes
  
  \end{verbatim}
  
  \section{Verification}
  \begin{verbatim}
  - data representation
  - connectiveness of the graph
  - possibility of panics can be detected
      - little usefulness in complex programs
  - simple deadlocks can already be detected
      - finding a correct formula is not trivial
          - panic paths mask normal execution deadlocks
          - splitting paths can mask deadlocks from single paths
  - more sophisticated approach is necessary
  \end{verbatim}